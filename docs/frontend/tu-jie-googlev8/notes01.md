# 笔记1

[链接](https://time.geekbang.org/column/article/211682)

宏观思想、JS设计思想篇

## [V8是如何执行一段Javascript代码的](https://time.geekbang.org/column/article/211682)

### 什么是V8?

*   核心的两步：编译、执行

    将低级代码 -> 中间代码/机器代码，然后执行编译后的代码并输出至执行结果。
* 可以把V8看作一个虚拟机，通过模拟实际计算机的各种功能来实现代码执行，如模拟**CPU**、**堆栈**、**寄存器**等，虚拟机还有自己的**一套指令系统**。
* 当V8执行JS代码时，并不需要担心现实中不同操作系统的差异，也不需要担心不同体系结构计算机的差异，只需要按照虚拟机的规范写好代码就可以了。

### 高级代码为什么要先编译再执行

```
1000100111011000  机器指令
mov ax,bx         汇编指令
```

* 汇编代码 -> 汇编编译器 -> 机器代码
*   首先，**不同的 CPU 有着不同的指令集**，如果要使用机器语言或者汇编语言来实现一个功能，那么你需要为每种架构的 CPU 编写特定的汇编代码，这会带来巨大的、枯燥繁琐的操作

    其次，**在编写汇编代码时，我们还需要了解和处理器架构相关的硬件知识**，比如你需要使用寄存器、内存、操作 CPU 等。大部分程序员在编写应用的时候，只想专心处理业务逻辑，并不想要过多地理会这些处理器架构相关的细节。

    因此我们需要一种屏蔽了计算机架构细节的语言，能适应多种不同 CPU 架构的语言，能专心处理业务逻辑的语言，诸如 C、C++、Java、C#、Python、JavaScript 等，这些“高级语言”就应运而生了。

    和汇编语言一样，**处理器也不能直接识别由高级语言所编写的代码**，那怎么办呢？通常，要有两种方式来执行这些代码。

    1.  解释执行

        需要先将输入的源代码通过**解析器**编译成中间代码，之后直接使用**解释器**解释执行中间代码，然后直接输出结果。

        对于像 Java 语言、JavaScript 语言等，则需要不同虚拟机，模拟计算机的这个编译执行流程。执行 Java 语言，需要经过 Java 虚拟机的转换，执行 JavaScript 需要经过 JavaScript 虚拟机的转换

        源代码 -> AST -> 中间代码(如字节码)，解析器将源代码解析为AST，解释器Ignition会根据 AST 生成字节码，并解释执行字节码。

        <img src="https://static001.geekbang.org/resource/image/33/5e/330ad69589d898f6609dfc083bfbe95e.jpg" alt="img" data-size="original" />
    2.  编译执行

        先将源代码转换为中间代码，然后我们的编译器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接**执行二进制文件**就可以了。**还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码**。执行 C 语言编写的代码，你需要将其编译为二进制代码的文件，然后再直接执行二进制代码

        源代码 -> 中间代码(如AST) -> 机器代码(二进制，直接执行)

        中间代码到机器代码使用编译器

        <img src="https://static001.geekbang.org/resource/image/1f/d3/1f933e42e81dacc8f4f2d86e01a914d3.jpg" alt="img" data-size="original" />

### V8是怎么执行JS代码的

* V8 并没有采用某种单一的技术，而是**混合编译执行和解释执行这两种手段**，我们把这种混合使用编译器和解释器的技术称为 \*\*JIT（Just In Time）\*\*技术。
* 在 V8 启动执行 JavaScript 之前，它还需要准**备执行 JavaScript 时所需要的一些基础环境**，这些基础环境包括了“**堆空间**”“**栈空间**”“**全局执行上下文**”“**全局作用域**”“**消息循环系统**”“**内置函数**”等，这些内容都是在执行 JavaScript 过程中需要使用到的:
  * JavaScript **全局执行上下文**就包含了执行过程中的全局信息，比如一些内置函数，全局变量等信息；
  * **全局作用域**包含了一些全局变量，在执行过程中的数据都需要存放在内存中；(作用域是用来查找变量的)
  * V8 是采用了经典的堆和栈的内存管理模式，所以 V8 还需要初始化内存中的**堆和栈结构**；
  * 想要我们的 V8 系统活起来，还需要初始化**消息循环系统**，消息循环系统包含了消息驱动器和消息队列，它如同 V8 的心脏，不断接受消息并决策如何处理消息。
*   首先，V8接受JS源代码，它需要结构化这段字符串。结构化之后，就**生成了语法树(AST)**，AST是便于V8理解的结构。

    在生成 AST 的同时，V8 还会生成相关的作用域，作用域中存放相关变量，我们会在《 06 | 作用域链：V8 是如何查找变量的？》和《12 | 延迟解析：V8 是如何实现闭包的？》这两节课中详细分析。
* 有了 AST 和作用域之后，接下来就可以**生成字节码**了，**字节码是介于 AST 和机器代码的中间代码**。但是与特定类型的机器代码无关，解释器可以直接解释执行字节码，或者通过编译器将其编译为二进制的机器代码再执行。我们会在 《13｜字节码（一）：V8 为什么又重新引入字节码？》这节课中详细介绍字节码的前世今生。
* 好了，生成了字节码之后，解释器就登场了，它会按照顺序**解释执行字节码**，并**输出执行结果**。
* 在解释执行字节码的过程中，如果发现了某一段代码会被重复多次执行，那么监控机器人就会将这段代码标记为**热点代码**。
* 当某段代码被标记为**热点代码**后，V8 就会将这段字节码丢给**优化编译器**，优化编译器会在后台将字节码**编译为二进制代码**，然后**再对编译后的二进制代码执行优化操作**，优化后的二进制机器代码的执行效率会得到大幅提升。如果下面再执行到这段代码时，那么 V8 会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。
* 和静态语言不同的是，**JavaScript 是一种非常灵活的动态语言，对象的结构和属性是可以在运行时任意修改的**，而**经过优化编译器优化过的代码只能针对某种固定的结构**，一旦在执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，**这时候优化编译器就需要执行反优化操作**，经过反优化的代码，下次执行时就会回退到解释器解释执行。
* 可以用d8打印ast、scope、bytecode等。还可以查看哪些代码被( 反)优化了

### 总结

V8 是由 Google 开发的开源 JavaScript 引擎，也被称为虚拟机，模拟实际计算机各种功能来实现代码的编译和执行。那么，要想搞清楚 V8 内部的工作流程和原理，我们可以从分析计算机对语言的编译和执行过程入手。

因为计算机只能识别二进制指令，所以要让计算机执行一段高级语言通常有两种手段

1. 将高级代码转换为二进制代码，再让计算机去执行；
2. 在计算机安装一个解释器，并由解释器来解释执行。

解释执行和编译执行都有各自的优缺点:

* 解释执行启动速度快，但是执行时速度慢;
* 而编译执行启动速度慢，但是执行速度快。

为了充分地利用解释执行和编译执行的优点，规避其缺点，V8 采用了一种权衡策略，在启动过程中采用了**解释执行的策略**，但是**如果某段代码的执行频率超过一个值**，那么 V8 就会**采用优化编译器将其编译成执行效率更加高效的机器代码**。理解了这一点，我们就可以来深入分析 V8 执行一段 JavaScript 代码所经历的主要流程了，这包括了：

## [函数即对象：一篇文章彻底搞懂JavaScript的函数特点](https://time.geekbang.org/column/article/212123)

### 什么是JS对象

* JavaScript 中的函数非常灵活，其根本原因在于 JavaScript 中的函数就是一种**特殊的对象**，我们把 JavaScript 中的函数称为**一等公民 (First Class Function)**。
* 基于函数是一等公民的设计，使得 JavaScript 非常容易实现一些特性，比如**闭包**，还有**函数式编程**等，而其他语言要实现这些特性就显得比较困难，比如要在 C++ 中实现闭包需要实现大量复杂的代码，而且使用起来也异常复杂。
*   虽然 JavaScript 是基于对象设计的，但是它却**不是一门面向对象的语言 (Object—Oriented Programming Language)**，因为**面向对象语言天生支持封装、继承、多态**，但是 **JavaScript 并没有直接提供多态的支持**，因此要在 JavaScript 中使用多态并不是一件容易的事。

    面向对象语言是由语言本身对继承做了充分的支持，并提供了大量的关键字，如 public、protected、friend、interface 等，众多的关键字使得面向对象语言的继承变得异常繁琐和复杂，而 JavaScript 中实现继承的方式却非常简单清爽，\*\*只是在对象中添加了一个称为原型的属性，把继承的对象通过原型链接起来，就实现了继承，我们把这种继承方式称为基于原型链继承。\*\*关于 V8 是如何支持原型的，我们会在《05 | 原型链：V8 是如何实现对象继承的？》这节课做具体介绍。
* 对象的属性值有三种类型：
  1.  原始类型

      null、undefined、boolean、number、string、bigint、symbol
  2. 对象类型
  3.  函数类型

      如果对象中的属性值是**函数**，那么我们**把这个属性称为方法**，所以我们又说对象具备属性和方法。

### 函数的本质

* V8 内部是怎么实现函数可调用特性的呢？
* 其实在 V8 内部，会为函数对象添加了两个隐藏属性，分别是`name`属性和`code`属性。如果某个函数**没有设置函数名**，该函数对象的默认的 `name` 属性值就是`anonymous`，**表示该函数对象没有被设置名称**。
* 也就是说，函数除了可以拥有常用类型的属性值之外，还拥有两个隐藏属性，分别是 name 属性和 code 属性。

### 函数是一等公民

* 在 JavaScript 中
  1. **函数可以赋值给一个变量**
  2. 也**可以作为函数的参数**
  3. 还**可以作为函数的返回值**。
* \*\*如果某个编程语言的函数，可以和这个语言的数据类型做一样的事情，我们就把这个语言中的函数称为一等公民。\*\*支持函数是一等公民的语言可以使得代码逻辑更加清晰，代码更加简洁。
* 我们知道，在执行 JavaScript 函数的过程中，为了实现变量的查找，**V8 会为其维护一个作用域链**，如果**函数中使用了某个变量**，但是在函数内部又没有定义该变量，那么**函数就会沿着作用域链去外部的作用域中查找该变量**。当函数内部引用了外部的变量时，使用这个函数进行赋值、传参或作为返回值，你还**需要保证这些被引用的外部变量是确定存在的，这就是让函数作为一等公民麻烦的地方，因为虚拟机还需要处理函数引用的外部变量**。
* 所谓的“函数是一等公民”就体现在，如果要返回函数 bar 给外部，那么即便 foo 函数执行结束了，其内部定义的 number 变量也不能被销毁，因为 bar 函数依然引用了该变量。我们也把这种将外部变量和和函数绑定起来的技术称为闭包。

### 总结

* 函数作为一个对象，它有自己的属性和值，所以**函数关联了基础的属性和值**；
* 函数之所以成为特殊的对象，这个特殊的地方是**函数可以“被调用”**，所以一个函数被调用时，它还需要关联相关的执行上下文。

结合以上两点，JavaScript 中的函数就实现了“函数是一等公民”的特性。

## [快属性和慢属性：V8是怎样提升对象属性访问速度的？](https://time.geekbang.org/column/article/213250)

* 然而在 V8 实现对象存储时，并**没有完全采用字典的存储方式**，这主要是出于性能的考量。因为**字典是非线性的数据结构**，**查询效率会低于线性的数据结构**，V8 为了提升存储和查找效率，采用了一套复杂的存储策略。

### 常规属性 (properties) 和排序属性 (element)

* 我们把对象中的数字属性称为**排序属性**，在 V8 中被称为 `elements`，字符串属性就被称为**常规属性**，在 V8 中被称为 `properties`。
* 在 V8 内部，为了有效地**提升存储和访问这两种属性的性能**，**分别**使用了**两个线性数据结构**来分别保存排序属性和常规属性。
* 对象有隐藏属性`elements`和`properties`
  * elements 属性指向了 elements 对象，在 elements 对象中，会按照\*\*（数字）顺序\*\*存放排序属性
  * properties 属性则指向了 properties 对象，在 properties 对象中，会按照**创建时的顺序**保存了常规属性。

### 快属性和慢属性

* 将不同的属性分别保存到 elements 属性和 properties 属性中，无疑**简化了程序的复杂度**，**但是在查找元素时，却多了一步操作**，比如执行 bar.B这个语句来查找 B 的属性值，那么在 V8 会先查找出 properties 属性所指向的对象 properties，然后再在 properties 对象中查找 B 属性，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率。
* 基于这个原因，V8 采取了一个权衡的策略以加快查找属性的效率，这个策略是**将部分常规属性直接存储到对象本身，我们把这称为对象内属性 (in-object properties)**。
* 采用对象内属性之后，常规属性就被保存到 bar 对象本身了，这样当再次使用bar.B来查找 B 的属性值时，V8 就可以直接从 bar 对象本身去获取该值就可以了，这种方式减少查找属性值的步骤，增加了查找效率。
* 不过对象内属性的数量是固定的，**默认是 10 个**，如果添加的属性**超出了对象分配的空间，则它们将被保存在常规属性存储中**。虽然属性存储多了一层间接层，但可以自由地扩容。
* 通常，我们将**保存在线性数据结构中的属性称之为“快属性”**，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，**但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。**
* 因此，**如果一个对象的属性过多时，V8 就会采取另外一种存储策略，那就是“慢属性”策略**，但慢属性的对象**内部会有独立的非线性数据结构 (词典) 作为属性存储容器**。所有的属性元信息不再是线性存储的，而是直接**保存在属性字典**中。

### 其他属性

* 除了 elements 和 properties 属性，V8 还为每个对象实现了 `map` 属性和 `__proto__` 属性。`__proto__` 属性就是原型，是用来实现 JavaScript 继承的，我们会在下一节来介绍；而 `map` 则是隐藏类，我们会在《15 | 隐藏类：如何在内存中快速查找对象属性？》这一节中介绍其工作机制。

### 总结

* 为了提升查找效率，V8 在对象中添加了两个隐藏属性，排序属性和常规属性，element 属性指向了 elements 对象
  * 在 elements 对象中，会按照顺序存放排序属性。
  * properties 属性则指向了 properties 对象，在 properties 对象中，会按照创建时的顺序保存常规属性。
* 通过引入这两个属性，加速了 V8 查找属性的速度，为了更加进一步提升**查找效率**，V8 还实现了内置内属性的策略，当**常规属性少于一定数量时，V8 就会将这些常规属性直接写进对象中，这样又节省了一个中间步骤。**（快属性提高了查找效率）
* 但是如果对象中的**属性过多**时，或者**存在反复添加或者删除属性的操作**，那么 V8 就会将线性的存储模式**降级为非线性的字典存储模式**，这样**虽然降低了查找速度，但是却提升了修改对象的属性的速度。**（满属性提高了修改效率）

## [函数表达式：涉及大量概念，函数表达式到底该怎么学？](https://time.geekbang.org/column/article/215248)

实际上，**函数表达式**和**函数声明**有着本质上的差异。理解了这种差异，你对函数表达式的理解也就加深了。

### 函数声明和函数表达式的差异

* 函数声明(Function Declaration)：

```js
foo()
function foo(){
    console.log('foo')
}
```

* 函数表达式(Function Expression)：

```js
foo()
var foo = function (){
    console.log('foo')
}
```

### V8怎么处理函数声明？

* V8 在执行 JavaScript 的过程中，会先对其进行编译，然后再执行
* 在编译阶段，如果解析到函数声明，那么 V8 会将这个函数声明转换为内存中的函数对象，并将其放到作用域中。同样，如果解析到了某个变量声明，也会将其放到作用域中，但是会将其值设置为 undefined，表示该变量还未被使用。(变量提升)
* 然后在 V8 执行阶段，如果使用了某个变量，或者调用了某个函数，那么 V8 便会去作用域查找相关内容。
* 函数也是一个对象，所以在**编译阶段**，V8 就**会将整个函数对象提升到作用域中**，并不是给该函数名称赋一个 undefined，理解这一点尤为重要:
  *   简单地理解，表达式就是表示值的式子，而语句是操作值的式子。

      ```js
      x = 5 // 表达式，因为执行这段代码会返回一个值
      var x // 语句，执行该语句不会返回值
      ```
  *   **表达式是不会在编译阶段执行的**，那么函数声明是表达式还是语句呢？你可以看下面这段函数声明：

      ```js
      function foo(){ console.log('Foo')}
      ```

      执行上面这段代码，它并没有输出任何内容，所以可以肯定，**函数声明并不是一个表达式，而是一个语句**。V8 在变量提升阶段，如果**遇到函数声明，那么 V8 同样会对该函数声明执行变量提升操作**。
* 总的来说，在 V8 解析 JavaScript 源码的过程中，如果遇到普通的变量声明，那么便会将其提升到作用域中，并给该变量赋值为 undefined，如果遇到的是函数声明，那么 V8 会在内存中为声明生成函数对象，并将该对象提升到作用域中。

### V8 是怎么处理函数表达式的？

函数表达式与函数声明的最主要区别有以下三点：

1. 函数表达式是在表达式语句中使用 `function` 的，最典型的表达式是`a=b`这种形式，因为函数也是一个对象，我们把`a = function (){}`这种方式称为函数表达式；
2. 在函数表达式中，可以省略函数名称，从而创建匿名函数（anonymous functions）；
3. 一个函数表达式可以被用作一个即时调用的函数表达式——IIFE（Immediately Invoked Function Expression）。

```js
var foo = undefined
foo = function (){
    console.log('foo')
}
```

* 第一行是声明语句，所以 **V8 在解析阶段，就会在作用域中创建该对象，并将该对象设置为 undefined**
* 第二行是函数表达式，**在编译阶段，V8 并不会处理函数表达式**，所以也就不会将该函数表达式提升到作用域中了。

### 立即调用的函数表达式（IIFE）

* 因为函数立即表达式也是一个表达式，所以 **V8 在编译阶段**，并**不会为该表达式创建函数对象**。这样的一个**好处就是不会污染环境**，函数和函数内部的变量都**不会被其他部分的代码访问到**。

### 总结

* 函数声明和变量声明类似，V8 在编译阶段，都会对其执行变量提升的操作，将它们提升到作用域中，在执行阶段，如果使用了某个变量，就可以直接去作用域中去查找。
* 不过 V8 对于提升函数和提升变量的策略是不同的，如果提升了一个**变量**，那么 V8 在将变量提升到作用域中时，还会为其设置默认值 `undefined`; 如果是**函数声明**，那么 V8 会在内存中创建该函数对象，并**提升整个函数对象**。

## [V8是如何实现对象继承的？](https://time.geekbang.org/column/article/215425)

### 原型继承如何实现

* `JavaScript` 的每个对象都包含了一个隐藏属性 `__proto__` ，我们就把该隐藏属性 `__proto__` 称之为该对象的原型 (prototype)，`__proto__` 指向了内存中的另外一个对象，我们就把 `__proto__` 指向的对象称为该对象的原型对象，那么该对象就可以直接访问其原型对象的方法或者属性。
* 继承就是一个对象可以访问另外一个对象中的属性和方法，在JavaScript 中，我们通过**原型和原型链**的方式来实现了继承特性。

### 实践：利用 **proto** 实现继承

```js
var animal = {
    type: "Default",
    color: "Default",
    getInfo: function () {
        return `Type is: ${this.type}，color is ${this.color}.`
    }
}
var dog = {
    type: "Dog",
    color: "Black",
}
```

* 在上面这段代码中，我创建了两个对象 animal 和 dog，我想让 dog 对象继承于 animal 对象，那么最直接的方式就是将 dog 的原型指向对象 animal，应该怎么操作呢？我们可以通过设置 dog 对象中的 `__proto__` 属性，将其指向 animal

```js
dog.__proto__ = animal
```

* 还有一点我们要注意，通常隐藏属性是不能使用 JavaScript 来直接与之交互的。虽然现代浏览器都开了一个口子，让 JavaScript 可以访问隐藏属性 `__proto__`，但是在实际项目中，我们不应该直接通过 `__proto__` 来访问或者修改该属性，其主要原因有两个：
  1. 这是隐藏属性，并不是标准定义的 ;
  2. 使用该属性会造成严重的性能问题。

### 构造函数怎么创建对象

*   创建对象：

    ```js
    function DogFactory(type,color){
        this.type = type
        this.color = color
    }
    var dog = new DogFactory('Dog','Black')
    ```
*   当 V8 执行上面这段代码时，V8 会在背后悄悄地做了以下几件事情，模拟代码如下所示：

    ```js
    var dog = {}  
    dog.__proto__ = DogFactory.prototype
    DogFactory.call(dog,'Dog','Black')
    ```

    更完整的版本：

    ```js
    function mynew(Func, ...args) {
        // 1.创建一个新对象
        const obj = {}
        // 2.新对象原型指向构造函数原型对象
        obj.__proto__ = Func.prototype
        // 3.将构建函数的this指向新对象
        let result = Func.apply(obj, args)
        // 4.根据返回值判断
        return result instanceof Object ? result : obj
    }
    ```

    我们可以看到执行流程分为三步：

    1. 创建了一个空白对象 dog；
    2. 将 DogFactory 的 prototype 属性设置为 dog 的原型对象，这就是给 dog 对象设置原型对象的关键一步，我们后面来介绍；
    3. 使用 dog 来调用 DogFactory，这时候 DogFactory 函数中的 this 就指向了对象 dog，然后在 DogFactory 函数中，利用 this 对对象 dog 执行属性填充操作，最终就创建了对象 dog。

### 构造函数怎么实现继承？

* 每个**函数对象**中都有一个公开的 prototype 属性，当你将这个函数作为构造函数来创建一个新的对象时，新创建对象的原型对象就指向了该函数的 prototype 属性。当然了，如果你只是正常调用该函数，那么 prototype 属性将不起作用。

### 总结

* **每个对象中都有的隐含属性** `__proto__`，来介绍了什么是原型和原型链。V8 为每个对象都设置了一个 `__proto__` 属性，**该属性直接指向了该对象的原型对象**，**原型对象也有自己的** `__proto__` 属性，**这些属性串连在一起就成了原型链**。
*   不过在 JavaScript 中，并不建议直接使用 `__proto__` 属性，主要有两个原因。

    1. 这是隐藏属性，并不是标准定义的；
    2. 使用该属性会造成严重的性能问题。

    所以，在 JavaScript 中，是使用 new 加上构造函数的这种组合来创建对象和实现对象的继承。不过使用这种方式隐含的语义过于隐晦，所以理解起来有点难度。

    为什么 JavaScript 中要使用这种怪异的方式来创建对象？为了理解这个问题，我们回顾了一段 JavaScript 的历史。由于当前的 Java 非常流行，基于市场推广的考虑，**JavaScript 采取了蹭 Java 热度的策略**，在语言命名上使用了 Java 字样，在语法形式上也模仿了 Java。事实上通过这些策略，确实为 JavaScript 带来了市场上的成功。不过你依然要记住，JavaScript 和 Java 是完全两种不同的语言。

## [作用域链：V8是如何查找变量的？](https://time.geekbang.org/column/article/217027)

作用域链就是将一个个作用域串起来，实现变量查找的路径。讨论作用域链，实际就是在讨论**按照什么路径查找变量的问题**。

我们知道，作用域就是存放变量和函数的地方，全局环境有全局作用域，全局作用域中存放了全局变量和全局函数。每个函数也有自己的作用域，函数作用域中存放了函数中定义的变量。

当在函数内部使用一个变量的时候，V8 便会去作用域中去查找。

### 什么是函数作用域和全局作用域？

*   **每个函数在执行时都需要查找自己的作用域，我们称为函数作用域**，在执行阶段，在执行一个函数时，当该函数需要使用某个变量或者调用了某个函数时，便会**优先在该函数作用域中查找相关内容**。

    使用Chrome控制台，打上断点，Scope里的Local就是当前函数作用域。

    <img src="https://user-images.githubusercontent.com/17645053/160735449-503a493b-b448-45dd-bcf6-dcd3f21b4a52.png" alt="Screen Shot 2022-03-30 at 9 58 13 AM" data-size="original" />

    另外你还需要注意下，第一个 `test1`，我并**没有采用 `var` 等关键字来声明**，所以 `test1` 并**不会出现在 `test_scope` 函数的作用域中**，而是**属于 `this` 所指向的对象**。（`this` 的工作机制不是本文讨论的重点，不展开介绍。如果你感兴趣，可以在《浏览器工作原理与实践》专栏中《11 | this：从 JavaScript 执行上下文的视角讲清楚 this》这一讲查看。）
*   全局作用域和函数作用域类似，也是存放变量和函数的地方，但是它们还是有点不一样： **全局作用域是在 V8 启动过程中就创建了，且一直保存在内存中不会被销毁的，直至 V8 退出**。 而函数作用域是**在执行该函数时创建的，当函数执行结束之后，函数作用域就随之被销毁掉了**。

    全局作用域中包含了很多全局变量，比如全局的 this 值，如果是浏览器，全局作用域中还有 `window`、`document`、`opener` 等非常多的方法和对象，如果是 `node` 环境，那么会有 `Global`、`File` 等内容。

    V8 启动之后就进入正常的消息循环状态，这时候就可以执行代码了，比如执行到上面那段脚本时，V8 会先解析顶层 (Top Level) 代码，我们可以看到，在顶层代码中定义了变量 x，这时候 V8 就会将变量 x 添加到全局作用域中。

### 作用域链是怎么工作的?

```js
var name = '极客时间'
var type = 'global'


function foo(){
    var name = 'foo'
    console.log(name)
    console.log(type)
}


function bar(){
    var name = 'bar'
    var type = 'function'
    foo()
}
bar()
```

1.  首先**当 V8 启动时，会创建全局作用域**，全局作用域中包括了 this、window 、document等变量，还有一些全局的 Web API 接口，创建的作用域如下图所示：

    <img src="https://user-images.githubusercontent.com/17645053/160736003-f9e5d51a-59df-434d-9d60-363afb3b19fa.png" alt="Screen Shot 2022-03-30 at 10 04 13 AM" data-size="original" />
2.  **V8 启动之后，消息循环系统便开始工作了**，这时候，我输入了这段代码，让其执行。V8 会**先编译顶层代码**，在编译过程中会将顶层定义的**变量**(`name`、`type`)和**声明的函数**(`foo`、`bar`)都添加到**全局作用域**中，最终的全局作用域如下图所示：

    <img src="https://user-images.githubusercontent.com/17645053/160736338-f7d5ec4a-d03c-4cb9-bf24-09420c7e1ef4.png" alt="Screen Shot 2022-03-30 at 10 06 51 AM" data-size="original" />
3.  **全局作用域创建完成之后，V8 便进入了执行状态**。前面我们介绍了变量提升，因为变量提升的原因，你可以把上面这段代码分解为如下两个部分：

    ```js
    //======解析阶段--实现变量提升=======
    var name = undefined
    var type = undefined
    function foo(){
        var name = 'foo'
        console.log(name)
        console.log(type)
    }
    function bar(){
        var name = 'bar'
        var type = 'function'
        foo()
    }




    //====执行阶段========
    name = '极客时间'
    type = 'global'
    bar()
    ```

    第一部分是在编译过程中完成的，此时全局作用中两个变量的值依然是 undefined，然后进入执行阶段；

    第二部代码就是执行时的顺序，首先全局作用域中的两个变量赋值“极客时间”和“global”，然后就开始执行函数 bar 的调用了。
4.  当 V8 执行 bar 函数的时候，同样需要经历两个阶段：编译和执行。在**编译阶段**，V8 会**为 bar 函数创建函数作用域**，最终效果如下所示：

    <img src="https://user-images.githubusercontent.com/17645053/160738124-03aed099-7d90-4716-8163-0c7e7c122336.png" alt="Screen Shot 2022-03-30 at 10 23 04 AM" data-size="original" />

    然后进入了 bar 函数的执行阶段。在 bar 函数中，只是简单地调用 foo 函数，因此 V8 又开始执行 foo 函数了。同样，**在编译 foo 函数的过程中，会创建 foo 函数的作用域**，最终创建效果如下图所示：

    <img src="https://user-images.githubusercontent.com/17645053/160738274-1ee13158-02ac-4afd-af69-40c5d2422a48.png" alt="Screen Shot 2022-03-30 at 10 24 36 AM" data-size="original" />

*   好了，这时候我们就有了三个作用域了，分别是全局作用域、bar 的函数作用域、foo 的函数作用域。

    现在我们就可以将刚才提到的问题转换为作用域链的问题了：foo 函数查找变量的路径到底是什么？

    * 沿着 foo 函数作用域 -> bar 函数作用域–> 全局作用域 ;还是，
    * 沿着 foo 函数作用域 -> 全局作用域？

    因为 JavaScript 是**基于词法作用域**的，词法作用域就是指，**查找作用域的顺序是按照函数定义时的位置来决定的**。**bar 和 foo 函数的外部代码都是全局代码**，所以无论你是在 bar 函数中查找变量，还是在 foo 函数中查找变量，其查找顺序都是**按照当前函数作用域–> 全局作用域**这个路径来的。

    \*\*由于我们代码中的 foo 函数和 bar 函数都是在全局下面定义的，所以在 foo 函数中使用了 type，最终打印出来的值就是全局作用域中的 type。\*\*你可以参考下面这张图：

    <img src="https://user-images.githubusercontent.com/17645053/160738556-56b2516e-9176-41c2-b17d-1a06f1302df6.png" alt="Screen Shot 2022-03-30 at 10 26 53 AM" data-size="original" />
* 另外，我再展开说一些。因为词法作用域是根据函数在代码中的位置来确定的，**作用域是在声明函数时就确定好的了**，所以我们也将词法作用域称为**静态作用域**。
* 和静态作用域相对的是**动态作用域**，动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们**从何处调用**。换句话说，作用域链是基于调用栈的，而不是基于函数定义的位置的。（动态作用域不是本文讨论的重点，如果你感兴趣，可以参考《浏览器工作原理与实践》专栏中的《10 | 作用域链和闭包 ：代码中出现相同的变量，JavaScript 引擎是如何选择的？》这一节。）

### 总结

今天，我们主要解释了一个问题，那就是在一个函数中，如果使用了一个变量，或者调用了另外一个函数，V8 将会怎么去查找该变量或者函数。

为了解释清楚这个问题，我们引入了作用域的概念。**作用域就是用来存放变量和函数的地方**，全局作用域中存放了全局环境中声明的变量和函数，函数作用域中存放了函数中声明的变量和函数。**当在某个函数中使用某个变量时，V8 就会去这些作用域中查找相关变量。沿着这些作用域查找的路径，我们就称为作用域链。**

要了解查找路径，我们需要明白词法作用域，词法作用域是按照代码定义时的位置决定的，而 JavaScript 所采用的作用域机制就是词法作用域，所以作用域链的路径就是按照词法作用域来实现的。

## [类型转换：V8是怎么实现1+“2”的](https://time.geekbang.org/column/article/218499)

```js
>>> 1+'2'
>>> "12" // 为什么在 JavaScript 中执行，输出的是字符串“12”，不是数字 3 或者字符串“3”呢？
```

### 什么是类型系统 (Type System)？

Wiki:

> 在计算机科学中，类型系统（type system）用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，如何操作这些类型，这些类型如何互相作用。

* 直观地理解，一门语言的**类型系统**定义了**各种类型之间应该如何相互操作**，比如，两种不同类型相加应该如何处理，两种相同的类型相加又应该如何处理等。还规定了各种不同类型应该如何相互转换，比如字符串类型如何转换为数字类型。

### V8是怎么执行加法操作的？

```js
a+b
```

*   V8 会严格根据 ECMAScript 规范来执行操作。ECMAScript 是一个语言标准，JavaScript 就是 ECMAScript 的一个实现，比如在 ECMAScript 就定义了怎么执行加法操作，如下所示：

    <img src="https://user-images.githubusercontent.com/17645053/160741164-7251244f-acc5-4545-b40a-4613d5033824.png" alt="image" data-size="original" />
*   具体细节你也可以参考规范，我将标准定义的内容翻译如下：

    > AdditiveExpression : AdditiveExpression + MultiplicativeExpression

    1. 把第一个表达式 (`AdditiveExpression`) 的值赋值给左引用 (`lref`)。
    2. 使用 `GetValue(lref)` 获取左引用 (`lref`) 的计算结果，并赋值给左值。
    3. 使用`ReturnIfAbrupt(lval)` 如果报错就返回错误。
    4. 把第二个表达式 (`MultiplicativeExpression`) 的值赋值给右引用 (`rref`)。
    5. 使用 `GetValue(rref)` 获取右引用 (`rref`) 的计算结果，并赋值给 `rval`。
    6. 使用`ReturnIfAbrupt(rval)` 如果报错就返回错误。
    7. 使用 `ToPrimitive(lval)` 获取左值 (`lval`) 的计算结果，并将其赋值给左原生值 (`lprim`)。
    8. 使用 `ToPrimitive(rval)` 获取右值 (`rval`) 的计算结果，并将其赋值给右原生值 (`rprim`)。
    9.  如果 `Type(lprim)` 和 `Type(rprim)` 中有一个是 `String`，则：

        ​ a. 把 `ToString(lprim)` 的结果赋给左字符串 (`lstr`)；

        ​ b. 把 `ToString(rprim)` 的结果赋给右字符串 (`rstr`)；

        ​ c. 返回左字符串 (`lstr`) 和右字符串 (`rstr`) 拼接的字符串。
    10. 把`ToNumber(lprim)`的结果赋给左数字 (`lnum`)。
    11. 把`ToNumber(rprim)`的结果赋给右数字 (`rnum`)。
    12. 返回左数字 (`lnum`) 和右数字 (`rnum`) 相加的数值。
*   通俗地理解，V8 会提供了一个 `ToPrimitive` 方法，其作用是**将 a 和 b 转换为原生数据类型**，其转换流程如下：

    1. 先检测该对象中是否存在 `valueOf` 方法，如果有并返回了原始类型，那么就使用该值进行强制类型转换；
    2. 如果 `valueOf` 没有返回原始类型，那么就使用`toString`方法的返回值；
    3. 如果 `vauleOf` 和 `toString` 两个方法都**不返回基本类型值**，便会触发一个 `TypeError` 的错误。

    <img src="https://static001.geekbang.org/resource/image/d1/aa/d150309b74f2c06e66011cf3e177dbaa.jpg" alt="img" data-size="original" />
*   当 V8 执行 1+“2”时，因为这是两个原始值相加，原始值相加的时候，**如果其中一项是字符串，那么 V8 会默认将另外一个值也转换为字符串**，相当于执行了下面的操作：

    ```js
    Number(1).toString() + "2"
    ```
*   一个例子验证上面的流程：

    ```js
    var Obj = {
      toString() {
      	return '200'
      }, 
      valueOf() {
      	return 100
      }   
    }
    Obj + 3
    ```

    上面我们介绍过了，由于需要先使用 `ToPrimitive` 方法将`Obj`转换为原生类型，而 `ToPrimitive` 会优先调用对象中的 `valueOf` 方法，由于`valueOf`返回了 100，那么 `Obj` 就会被转换为数字 100，那么数字 100 加数字 3，那么结果当然是 103 了。
*   如果我改造下代码，让 valueOf 方法和 toString 方法都返回对象，其改造后的代码如下：

    ```js
    var Obj = {
      toString() {
        return new Object()
      }, 
      valueOf() {
        return new Object()
      }   
    }
    Obj + 3
    ```

    因为`ToPrimitive`会先调用 `valueOf` 方法，发现返回的是一个对象，并不是原生类型，当 `ToPrimitive` 继续调用 `toString` 方法时，发现 `toString` 返回的也是一个对象，都是对象，就无法执行相加运算了，这时候虚拟机就会抛出一个异常，异常如下所示：

    ```js
    VM263:9 Uncaught TypeError: Cannot convert object to primitive value
        at <anonymous>:9:6
    ```

    提示的是类型错误，错误原因是无法将对象类型转换为原生类型。
* 所以说，在执行加法操作的时候，V8 会通过 `ToPrimitive` 方法将对象类型转换为原生类型，最后就是两个原生类型相加，如果其中一个值的类型是字符串时，则另一个值也需要强制转换为字符串，然后做字符串的连接运算。在其他情况时，所有的值都会转换为数字类型值，然后做数字的相加。

### 总结

* 今天我们主要学习了 `JavaScript` 中的类型系统是怎么工作的。类型系统定义了语言应当如何操作类型，以及这些类型如何互相作用。因为`Python`和 `JavaScript` 的类型系统差异，所以当处理同样的表达式时，返回的结果是不同的。
* 在 `Python` 中，数字和字符串相加会抛出异常，这是因为 `Python` 认为字符串和数字相加是无意义的，所以限制其操作。
* 在 `JavaScript` 中，数字和字符串相加会返回一个新的字符串，这是因为 `JavaScript` 认为字符串和数字相加是有意义的，V8 会将其中的数字转换为字符，然后执行两个字符串的相加操作，最终得到的是一个新的字符串。
* 在 `JavaScript` 中，类型系统是依据 `ECMAScript` 标准来实现的，所以 **V8 会严格根据 `ECMAScript` 标准来执行**。在执行加法过程中，V8 会先通过 `ToPrimitive` 函数，将对象转换为原生的字符串或者是数字类型，在转换过程中，`ToPrimitive` 会先调用对象的 `valueOf` 方法，如果没有 `valueOf` 方法，则调用 `toString` 方法，如果 `vauleOf` 和 `toString` 两个方法都不返回基本类型值，便会触发一个`TypeError`的错误。

## [如何构建和使用V8的调试工具d8？](https://time.geekbang.org/column/article/219418)

d8 是一个非常有用的调试工具，你可以把它看成是 **debug for V8** 的缩写。我们可以使用 d8 来查看 V8 在执行 JavaScript 过程中的各种中间数据，比如**作用域、AST、字节码、优化的二进制代码、垃圾回收的状态，还可以使用 d8 提供的私有 API 查看一些内部信息。**
